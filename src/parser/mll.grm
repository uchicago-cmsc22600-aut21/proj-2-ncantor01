(* mll.grm
 *
 * COPYRIGHT (c) 2021 John Reppy (http://cs.uchicago.edu/~jhr)
 * All rights reserved.
 *
 * Sample code
 * CMSC 22600
 * Autumn 2021
 * University of Chicago
 *
 * ML-Antlr specification for ML Lite.
 *)

%name MLL;

%defs (
  structure PT = ParseTree
  structure Op = OpNames

  type pos = Error.pos

);

(* MLL tokens *)
%tokens
    : KW_case           ("case")
    | KW_data           ("data")
    | KW_else           ("else")
    | KW_end            ("end")
    | KW_fun            ("fun")
    | KW_if             ("if")
    | KW_let            ("let")
    | KW_of             ("of")
    | KW_then           ("then")
    | LP                ("(")
    | RP                (")")
    | LB                ("[")
    | RB                ("]")
    | LCB               ("{")
    | RCB               ("}")
    | ASSIGN            (":=")
    | ORELSE            ("||")
    | ANDALSO           ("&&")
    | EQEQ              ("==")
    | NEQ               ("!=")
    | LTEQ              ("<=")
    | LT                ("<")
    | CONS              ("::")
    | CONCAT            ("^")
    | PLUS              ("+")
    | MINUS             ("-")
    | TIMES             ("*")
    | DIV               ("/")
    | MOD               ("%")
    | DEREF             ("!")
    | EQ                ("=")
    | COMMA             (",")
    | SEMI              (";")
    | BAR               ("|")
    | ARROW             ("->")
    | DARROW            ("=>")
    | WILD              ("_")
    | UID of Atom.atom
    | LID of Atom.atom
    | NUMBER of IntInf.int
    | STRING of string
    ;

%start PreProg;

PreProg
        : Program@([])
        ;

Program(env)
        (*This Exp is a Valbind*)
        : Exp (";" Program@(PT.BindExp Exp :: env))? => (case SR of
                        NONE => (PT.ProgMark (FULL_SPAN, PT.Prog (env, Exp) ))
                        SOME a => () )
        | TopDcl ";" Program@(TopDcl :: env)=> ()
        ;

TopDcl
        : "data" UID TyParams? "=" ConDcl ( "|" ConDcl => ( ConDcl ))* 
            => (case TyParams of
                SOME a => ( PT.DclData( UID, a, List.concat( [ConDcl :: [], SR] ) ) )
                | NONE => ( PT.DclData( UID, [], List.concat( [ConDcl :: [], SR] ) ) ) )
                (*END OF CASE*)
        | ValBind
        ;

TyParams 
        : "[" LID  ("," LID => ( LID ))* "]" => ( List.concat ([LID :: [], SR]) )
        ;

ConDcl 
        : UID ( "of" Type )? => ( PT.ConMark({span : "CON_SPAN", tree : PT.Con( UID, SR )} ) )
        ;

Type
        : AtomicTypeList ( "->" AtomicTypeList => (AtomicTypeList) )* 
            => ( case SR of
                [] => (AtomicTypeList)
              | _  => (list.foldl ( fn ( left, right ) => PT.TyFun ( left, right ) ) AtomicTypeList SR  ) )
        ;

AtomicTypeList        
        : AtomicType ( "*" AtomicType => ( AtomicType ) )* =>
            ( case SR of
                [] => ( PT.TyVar AtomicType )
              | _  => ( PT.TyTuple ( List.concat( [AtomicType :: [], SR] ) ) ) )
        ;

AtomicType
        : UID TyArgs?
            => (case TyArgs of
                SOME a => ( PT.TyCon( UID, a ) )
                | NONE => ( PT.TyVar( UID ) ) )
                (*END OF CASE*) 
        | LID => ( PT.TyVar( LID ) )
        | "(" Type ")" => ( Type )
        ;

TyArgs 
        : "[" Type ("," Type => ( Type ))* "]" => ()
        ;
                                                                        
ValBind
        : "let" AtomicPat "=" Exp => ()
        | "fun" LID AtomicPat+ "=" Exp => ()
        ;

Pat
        : UID SimplePat? => ()
        | SimplePat "::" SimplePat => ()
        | AtomicPat => ()
        ;

AtomicPat
        : "(" SimplePat ("," SimplePat => ( SimplePat ) )* ")" => ()
        | SimplePat
        ;

SimplePat
        : LID => ()
        ;

Exp
        : "if" Exp "then" Exp "else" Exp => (PT.ExpIf (Exp1, Exp2, Exp3))
        | OpExp (":=" OpExp => (OpExp))? => ()
        ;

OpExp 
        : OpExp1 ( "||" OpExp1 => ( ("||", OpExp1) )
                | "&&" OpExp1 => ( ("&&", OpExp1) ))* => ()
        ;

OpExp1
        : OpExp2 ( "==" OpExp2 => ( ("==", OpExp2) )
                | "!=" OpExp2 => ( ("!=", OpExp2) )
                | "<"  OpExp2 => ( ("<" , OpExp2) )
                | "<=" OpExp2 => ( ("<=", OpExp2) ))* => ()
        ;

OpExp2
        : OpExp3 ( "::" OpExp3 => ( ("::", OpExp3) ))* => ()
        ;

OpExp3
        : OpExp4 ( "^"  OpExp4 => ( ("^" , OpExp4) )
                | "+"  OpExp4 => ( ("+" , OpExp4) )
             (*On second minus we know there is a binop and a unop*) 
                | "-" ("-")?  OpExp4 => ( ("-" , OpExp4) ))* => ()
        ;

OpExp4
        : OpExp5 ( "*"  OpExp5 => ( ("*" , OpExp5) )
                | "/"  OpExp5 => ( ("/" , OpExp5) )
                | "%"  OpExp5 => ( ("%" , OpExp5) ))* => ()
        ;

OpExp5
        : "!" ApplyExp => ()
        | ApplyExp     => ()
        ;


ApplyExp
        : AtomicExp => ()
        | ApplyExp AtomicExp => ()
        ;


AtomicExp
        : UID => ()
        | LID => ()
        | STRING => ()
        | NUMBER => ()
        | "(" ( Exp ("," Exp => (Exp))* )+")" => ()
        | "{" Scope "}" => ()
        | "case" Exp "of" (MatchCase)+ => ()
        ;  

Scope 
        (*This Exp is a Valbind*)
        : Exp (";" Exp)? => () 
        | ValBind ";" Scope => (PT.scope(SR, Exp))
        ;

MatchCase
        : "{" Pat "=>" Scope "}" => ()
        ;


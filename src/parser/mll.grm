(* mll.grm
 *
 * COPYRIGHT (c) 2021 John Reppy (http://cs.uchicago.edu/~jhr)
 * All rights reserved.
 *
 * Sample code
 * CMSC 22600
 * Autumn 2021
 * University of Chicago
 *
 * ML-Antlr specification for ML Lite.
 *)

%name MLL;

%defs (
  structure PT = ParseTree
  structure Op = OpNames

  type pos = Error.pos

);

(* MLL tokens *)
%tokens
    : KW_case           ("case")
    | KW_data           ("data")
    | KW_else           ("else")
    | KW_end            ("end")
    | KW_fun            ("fun")
    | KW_if             ("if")
    | KW_let            ("let")
    | KW_of             ("of")
    | KW_then           ("then")
    | LP                ("(")
    | RP                (")")
    | LB                ("[")
    | RB                ("]")
    | LCB               ("{")
    | RCB               ("}")
    | ASSIGN            (":=")
    | ORELSE            ("||")
    | ANDALSO           ("&&")
    | EQEQ              ("==")
    | NEQ               ("!=")
    | LTEQ              ("<=")
    | LT                ("<")
    | CONS              ("::")
    | CONCAT            ("^")
    | PLUS              ("+")
    | MINUS             ("-")
    | TIMES             ("*")
    | DIV               ("/")
    | MOD               ("%")
    | DEREF             ("!")
    | EQ                ("=")
    | COMMA             (",")
    | SEMI              (";")
    | BAR               ("|")
    | ARROW             ("->")
    | DARROW            ("=>")
    | WILD              ("_")
    | UID of Atom.atom
    | LID of Atom.atom
    | NUMBER of IntInf.int
    | STRING of string
    ;

%start PreProg;

PreProg
        : Program@([])
        ;

Program(env)
        (*This Exp is a Valbind*)
        : Exp (";" Program@(PT.BindExp Exp :: env))? => (case SR of
                        NONE => (PT.ProgMark (span = FULL_SPAN, tree = PT.Prog (env, Exp) ))
                        SOME a => () )
        | TopDcl ";" Program@(TopDcl :: env)=> ()
        ;

TopDcl
        : "data" UID TyParams? "=" ConDcl ( "|" ConDcl => ( ConDcl ))*
        => (case TyParams of
                SOME a => ( PT.DclMark ( span = TopDcl_SPAN, tree = PT.DclData( UID, a, ConDcl :: SR ) ) ) 
                | NONE => ( PT.DclMark ( span = TopDcl_SPAN, tree = PT.DclData( UID, [], ConDcl :: SR  ) ) ) )
                (*END OF CASE*)
        | ValBind
        ;

TyParams 
        : "[" LID  ("," LID => ( LID ))* "]" => ( LID :: SR )
        ;

ConDcl 
        : UID ( "of" Type )? => ( PT.ConMark( ConDcl_SPAN, PT.Con( UID, SR ) ) )
        ;

Type
        : AtomicTypeList ( "->" AtomicTypeList => (AtomicTypeList) )* 
            => ( case SR of
                [] => (AtomicTypeList)
              | _  => (PT.TyMark (span = Type_SPAN, 
                                  tree = (list.foldl ( fn ( left, right ) 
                                            => PT.TyFun ( left, right ) ) AtomicTypeList SR  ) ) ) )
        ;

AtomicTypeList        
        : AtomicType ( "*" AtomicType => ( AtomicType ) )* =>
            ( case SR of
                [] => ( PT.TyMark ( span = AtomicTypeList_SPAN, tree = PT.TyVar AtomicType ) )
              | _  => ( PT.TyMark ( span = AtomicTypeList_SPAN, tree = PT.TyTuple AtomicType :: SR ) ) )
        ;

AtomicType
        : UID TyArgs?
            => (case TyArgs of
                SOME a => ( PT.TyMark ( span = AtomicType_SPAN, tree = PT.TyCon( UID, a ) ) )
                | NONE => ( PT.TyMark ( span = AtomicType_SPAN, tree = PT.TyVar( UID ) ) ) )
                (*END OF CASE*) 
        | LID => ( PT.TyMark ( span = AtomicType_SPAN, tree = PT.TyVar( LID ) ) )
        | "(" Type ")" => ( Type )
        ;

TyArgs 
        : "[" Type ("," Type => ( Type ))* "]" => (Type :: SR)
        ;
                                                                        
ValBind
        : "let" AtomicPat "=" Exp 
                    => ( PT.BindMark ( span = ValBind_SPAN, tree = PT.BindVal ( AtomicPat, Exp )) ) 
        | "fun" LID AtomicPat+ "=" Exp 
                    => ( PT.BindMark ( span = ValBind_SPAN, tree = PT.BindFun ( LID, AtomicPat, Exp ) ) )
        ;

Pat
        : UID SimplePat? 
                => ( PT.PatMark ( span = Pat_SPAN, tree = PT.PatCon ( UID, SimplePat ) ) )
        | SimplePat "::" SimplePat 
                => ( PT.PatMark ( span = Pat_SPAN, tree = PT.PatListCons ( SimplePat1, SimplePat2 ) ) )
        | AtomicPat => ()
        ;

AtomicPat
        : "(" SimplePat ("," SimplePat => ( SimplePat ) )* ")" 
                    => ( PT.PatMark ( span = AtomicPat_SPAN, tree = PT.PatTuple ( SR ) ) )
        | SimplePat => ( PT.PatMark ( span = AtomicPat_SPAN, tree = PT.PatVar (SimplePat) ) )
        ;

SimplePat
        : LID
        ;

Exp
        : "if" Exp "then" Exp "else" Exp => (PT.ExpIf (Exp1, Exp2, Exp3))
        | OpExp (":=" OpExp => (OpExp))? => ()
        ;

OpExp 
        : OpExp1 ( "||" OpExp1 => ( ("||", OpExp1) )
                | "&&" OpExp1 => ( ("&&", OpExp1) ))* => ()
        ;

OpExp1
        : OpExp2 ( "==" OpExp2 => ( ("==", OpExp2) )
                | "!=" OpExp2 => ( ("!=", OpExp2) )
                | "<"  OpExp2 => ( ("<" , OpExp2) )
                | "<=" OpExp2 => ( ("<=", OpExp2) ))* => ()
        ;

OpExp2
        : OpExp3 ( "::" OpExp3 => ( ("::", OpExp3) ))* => ()
        ;

OpExp3
        : OpExp4 ( "^"  OpExp4 => ( ("^" , OpExp4) )
                | "+"  OpExp4 => ( ("+" , OpExp4) )
             (*On second minus we know there is a binop and a unop*) 
                | "-" ("-")?  OpExp4 => ( ("-" , OpExp4) ))* => ()
        ;

OpExp4
        : OpExp5 ( "*"  OpExp5 => ( ("*" , OpExp5) )
                | "/"  OpExp5 => ( ("/" , OpExp5) )
                | "%"  OpExp5 => ( ("%" , OpExp5) ))* => ()
        ;

OpExp5
        : "!" ApplyExp => ()
        | ApplyExp     => ()
        ;


ApplyExp
        : AtomicExp (AtomicExp)* => ( PT.ExpMark ( span = FULL_SPAN, tree = PT.ExpTuple (AtomicExp :: SR) ) )
        ;


AtomicExp
        : UID => (PT.ExpCon UID)
        | LID => (PT.ExpVar LID)
        | STRING => (PT.ExpStr STRING)
        | NUMBER => (PT.ExpInt NUMBER)
        | "(" ( Exp ("," Exp => (Exp))* => (Exp :: SR) )? ")" 
                    => ( case SR of
                        NONE => PT.ExpMark ( span = AtomicExp_SPAN, tree =  PT.ExpTuple ([]) )
                        | SOME a => (case ( List.length a ) of
                                     1 => a 
                                     | _ => PT.ExpMark ( span = AtomicExp_SPAN, tree = PT.ExpTuple ( a ) ) ) )
        | "{" Scope@([]) "}" => ( PT.ExpMark ( span = AtomicExp_SPAN, tree = PT.ExpScope Scope ) )
        | "case" Exp "of" (MatchCase)+ "end" => ( PT.ExpMark ( span = AtomicExp_SPAN, tree = PT.ExpCase ( Exp, SR ) ) )
        ;  

Scope(env) 
        (*This Exp is a Valbind if there is a scope after it*)
        : Exp ( ";" Scope@( PT.BindMark ( span = Exp_SPAN, tree = PT.BindExp Exp ) :: env ) )? 
                => ( case SR of
                   SOME a => 
                   | NONE => ( env, Exp ) ) 
        | ValBind ";" Scope@(ValBind :: env)
        ;

MatchCase
        : "{" Pat "=>" Scope@([]) "}" => ()
        ;


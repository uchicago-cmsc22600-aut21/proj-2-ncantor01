(* mll.grm
 *
 * COPYRIGHT (c) 2021 John Reppy (http://cs.uchicago.edu/~jhr)
 * All rights reserved.
 *
 * Sample code
 * CMSC 22600
 * Autumn 2021
 * University of Chicago
 *
 * ML-Antlr specification for ML Lite.
 *)

%name MLL;

%defs (
  structure PT = ParseTree
  structure Op = OpNames

  type pos = Error.pos

);

(* MLL tokens *)
%tokens
    : KW_case           ("case")
    | KW_data           ("data")
    | KW_else           ("else")
    | KW_end            ("end")
    | KW_fun            ("fun")
    | KW_if             ("if")
    | KW_let            ("let")
    | KW_of             ("of")
    | KW_then           ("then")
    | LP                ("(")
    | RP                (")")
    | LB                ("[")
    | RB                ("]")
    | LCB               ("{")
    | RCB               ("}")
    | ASSIGN            (":=")
    | ORELSE            ("||")
    | ANDALSO           ("&&")
    | EQEQ              ("==")
    | NEQ               ("!=")
    | LTEQ              ("<=")
    | LT                ("<")
    | CONS              ("::")
    | CONCAT            ("^")
    | PLUS              ("+")
    | MINUS             ("-")
    | TIMES             ("*")
    | DIV               ("/")
    | MOD               ("%")
    | DEREF             ("!")
    | EQ                ("=")
    | COMMA             (",")
    | SEMI              (";")
    | BAR               ("|")
    | ARROW             ("->")
    | DARROW            ("=>")
    | WILD              ("_")
    | UID of Atom.atom
    | LID of Atom.atom
    | NUMBER of IntInf.int
    | STRING of string
    ;

%start Program;

Program
        : (TopDcl ";")* Exp => ()
        ;

TopDcl
        : "data" UID TyParams? "=" ConDcl ( "|" ConDcl => ( ConDcl ))* 
            => (case TyParams of
                SOME a => ( PT.DclData( UID, a, List.concat( [ConDcl :: [], SR] ) ) )
                | NONE => ( PT.DclData( UID, [], List.concat( [ConDcl :: [], SR] ) ) ) )
                (*END OF CASE*)
        | ValBind
        ;

TyParams 
        : "[" LID  ("," LID => ( LID ))* "]" => ( List.concat ([LID :: [], SR]) )
        ;

ConDcl 
        : UID ( "of" Type )? => ( PT.Con( UID, SR ) )
        ;

Type
        : AtomicTypeList ( "->" AtomicTypeList => (AtomicTypeList) )* 
            => ( case SR of
                [] => (AtomicTypeList)
              | _  => (list.foldl ( fn ( left, right ) => PT.TyFun ( left, right ) ) AtomicTypeList SR  ) )
        ;

AtomicTypeList        
        : AtomicType ( "*" AtomicType => ( AtomicType ) )* =>
            ( case SR of
                [] => ( PT.TyVar AtomicType )
              | _  => ( PT.TyTuple ( List.concat( [AtomicType :: [], SR] ) ) ) )
        ;

AtomicType
        : UID TyArgs?
            => (case TyArgs of
                SOME a => ( PT.TyCon( UID, a ) )
                | NONE => ( PT.TyVar( UID ) ) )
                (*END OF CASE*) 
        | LID => ( PT.TyVar( LID ) )
        | "(" Type ")" => ( Type )
        ;

TyArgs 
        : "[" Type ("," Type => ( Type ))* "]" => ()
        ;
                                                                        
ValBind
        : "let" AtomicPat "=" Exp => ()
        | "fun" LID AtomicPat+ "=" Exp => ()
        | Exp => (PT.BindExp( Exp ))
        ;

Pat
        : UID SimplePat? => ()
        | SimplePat "::" SimplePat => ()
        | AtomicPat => ()
        ;

AtomicPat
        : "(" SimplePat ("," SimplePat => ( SimplePat ) )* ")" => ()
        | SimplePat
        ;

SimplePat
        : LID => ()
        ;

Exp
        : "if" Exp "then" Exp "else" Exp => (PT.ExpIf (Exp1, Exp2, Exp3))
        | OpExp (":=" OpExp => (OpExp))? => ()
        ;

OpExp 
        : OpExp1 ( "||" OpExp1 => ("||", OpExp1)
                | "&&" OpExp1 => ("&&", OpExp1)
                | "==" OpExp1 => ("==", OpExp1)
                | "!=" OpExp1 => ("!=", OpExp1)
                | "<"  OpExp1 => ("<" , OpExp1)
                | "<=" OpExp1 => ("<=", OpExp1)
                | "::" OpExp1 => ("::", OpExp1)
                | "^"  OpExp1 => ("^" , OpExp1)
                | "+"  OpExp1 => ("+" , OpExp1)
                | "-"  OpExp1 => ("-" , OpExp1)
                | "*"  OpExp1 => ("*" , OpExp1)
                | "/"  OpExp1 => ("/" , OpExp1)
                | "%"  OpExp1 => ("%" , OpExp1))* => ()
        ;

OpExp1
        : "-" ApplyExp => ()
        | "!" ApplyExp => ()
        | ApplyExp     => ()
        ;


ApplyExp
        : AtomicExp (AtomicExp)* => ()
        ;


AtomicExp
        : UID => ()
        | LID => ()
        | STRING => ()
        | NUMBER => ()
        | "(" ( Exp ("," Exp => (Exp))* )+")" => ()
        | "{" Scope "}" => ()
        | "case" Exp "of" MatchCase => ()
        ;  

Scope 
        : ("(" (ValBind ";" => (ValBind) )* ")")* Exp => (PT.scope(SR, Exp))
        ;

MatchCase
        : "{" Pat "=>" Scope "}" => ()
        ;

